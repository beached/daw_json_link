<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DAW JSON Link: Dates and Times</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DAW JSON Link
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Dates and Times </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Timestmaps are common in JSON datasets. DAW JSON Link has a convienience type to serialize/deserialize ISO8601 timestamps.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
ISO 8601 Timestamps</h1>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;name&quot;: &quot;Toronto&quot;,</div>
<div class="line">  &quot;timestamp&quot;: &quot;2020-01-02T01:34:34.443Z&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above JSON object consists of a 2 string members, where the second stores an <a href="https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations">ISO8601</a> combinded representation timestamp.</p>
<p>Too see a working example using this code, refer to <a href="../tests/src/cookbook_dates1_test.cpp">cookbook_dates1_test.cpp</a></p>
<p>Below is code that code serialize/deserialize the above JSON using the <code>json_date</code> class.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct MyClass {</div>
<div class="line">  std::string name;</div>
<div class="line">  std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::milliseconds&gt; timestamp;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">namespace daw::json {</div>
<div class="line">  template&lt;&gt;</div>
<div class="line">  struct json_data_contract&lt;MyClass&gt; {</div>
<div class="line">    using type = json_member_list&lt;</div>
<div class="line">      json_string&lt;&quot;name&quot;&gt;,</div>
<div class="line">      json_date&lt;&quot;timestamp&quot;&gt;</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">    static inline auto to_json_data( MyClass const &amp; v ) {</div>
<div class="line">      return std::forward_as_tuple( v.name, v.timestamp );</div>
<div class="line">    }   </div>
<div class="line">  };</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md13"></a>
Custom string formats</h1>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;name&quot;: &quot;Toronto&quot;,</div>
<div class="line">  &quot;timestamp&quot;: &quot;Sun Aug 31 00:29:15 +0000 2014&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above json is like the first example, but the timestamp format is not iso8601. It is the date format used in some twitter JSON apis. The string member will be a <code>json_string</code> and the timestmap will use <code>json_custom</code>. This example is more involved and also outlines using <code>json_custom</code> to work with data that does not fit the other mappings.</p>
<p><code>json_custom</code> requires a callable FromJsonConverter and a callable ToJsonConverter type to convert to <code>T</code> from a <code>std::string_view</code> and to a string like type from a <code>T</code>.</p>
<p>The To and From Converters can be the same type with different overloads for <code>operator()</code>. T will be a <code>std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::milliseconds&gt;</code>.</p>
<p>Too see a working example using this code, refer to <a href="../tests/src/cookbook_dates2_test.cpp">cookbook_dates2_test.cpp</a></p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct TimestampConverter {</div>
<div class="line">  std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::milliseconds&gt;</div>
<div class="line">    operator( )( std::string_view sv ) const {</div>
<div class="line">    // ... See linked code</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::string_view operator( )( std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::milliseconds&gt; tp ) const {</div>
<div class="line">    // ... See linked code</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// Same class as above, but the JSON encoding differs</div>
<div class="line">struct MyClass2 {</div>
<div class="line">  std::string name;</div>
<div class="line">  std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::milliseconds&gt; timestamp;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">namespace daw::json {</div>
<div class="line">  template&lt;&gt;</div>
<div class="line">  struct json_data_contract&lt;MyClass2&gt; {</div>
<div class="line">    using type = json_member_list&lt;</div>
<div class="line">      json_string&lt;&quot;name&quot;&gt;,</div>
<div class="line">      json_custom&lt;&quot;timestamp&quot;, </div>
<div class="line">        std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::milliseconds&gt;, </div>
<div class="line">        TimestampConverter, </div>
<div class="line">        TimestampConverter</div>
<div class="line">      &gt;</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">    static inline auto to_json_data( MyClass2 const &amp; v ) {</div>
<div class="line">      return std::forward_as_tuple( v.name, v.timestamp );</div>
<div class="line">    }   </div>
<div class="line">  };</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
Unix time encoding</h2>
<p>A time_point can be encoded into JSON a the number of seconds since epoch(Jan 1, 1970 @ 12:00:00am ).</p>
<div class="fragment"><div class="line">{</div>
<div class="line"> &quot;title&quot;:&quot;The Title&quot;,</div>
<div class="line"> &quot;id&quot;:24,</div>
<div class="line"> &quot;dateAdded&quot;:&quot;1356753810000000&quot;,</div>
<div class="line"> &quot;lastModified&quot;:1356753810000000</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example will use the constructor of the class to construct the <code>time_point</code> from the integer. Otherwise, a <code>json_custom</code> type could be used here too. It demonstrates using a constructor to do the data conversions, along with <code>to_json_data</code> to reverse the conversion. Another alternative is to use the <code>Constructor</code> template argument to do the conversion of the integer to the <code>time_point</code>. The <code>dateAdded</code> member shows parsing strings into numbers. This is often done as numbers in JSON are double and can only hold integers as large as 2^53.</p>
<p>Too see a working example using this code, refer to <a href="../tests/src/cookbook_dates3_test.cpp">cookbook_dates3_test.cpp</a></p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">using my_timepoint = std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::milliseconds&gt;;</div>
<div class="line"> </div>
<div class="line">my_timepoint seconds_since_epoch_to_tp( int64_t seconds ) {</div>
<div class="line">  return my_timepoint{} + std::chrono::seconds( seconds );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct MyClass3 {</div>
<div class="line">  std::string title;</div>
<div class="line">  unsigned id;</div>
<div class="line">  my_timepoint date_added;</div>
<div class="line">  my_timepoint last_modified;</div>
<div class="line"> </div>
<div class="line">  MyClass3( std::string Title, unsigned Id, int64_t DateAdded,</div>
<div class="line">    int64_t LastModified )</div>
<div class="line">    : title( Title )</div>
<div class="line">    , id( Id )</div>
<div class="line">    , date_added( seconds_since_epoch_to_tp( DateAdded ) )</div>
<div class="line">    , last_modified( seconds_since_epoch_to_tp( LastModified ) ) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">bool operator==( MyClass3 const &amp;lhs, MyClass3 const &amp;rhs ) {</div>
<div class="line">  return std::tie( lhs.title, lhs.id, lhs.date_added, lhs.last_modified ) == std::tie( rhs.title, rhs.id, rhs.date_added, rhs.last_modified );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">namespace daw::json {</div>
<div class="line">  template&lt;&gt;</div>
<div class="line">  struct json_data_contract&lt;MyClass3&gt; {</div>
<div class="line">    using type = json_member_list&lt;</div>
<div class="line">      json_string&lt;&quot;title&quot;&gt;, </div>
<div class="line">      json_number&lt;&quot;id&quot;, unsigned&gt;,</div>
<div class="line">    json_number&lt;&quot;dateAdded&quot;, int64_t, LiteralAsStringOpt::Always&gt;,</div>
<div class="line">    json_number&lt;&quot;lastModified&quot;, int64_t&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">  static inline auto to_json_data( daw::cookbook_dates3::MyClass3 const &amp;v ) {</div>
<div class="line">    auto const date_added = std::chrono::floor&lt;std::chrono::seconds&gt;( v.date_added ).time_since_epoch( ).count( );</div>
<div class="line">    auto const last_modified = std::chrono::floor&lt;std::chrono::seconds&gt;( v.last_modified ).time_since_epoch( ).count( );</div>
<div class="line">    return std::tuple( std::as_const( v.title ), v.id, date_added, last_modified );</div>
<div class="line">  };</div>
<div class="line">} // namespace daw::json</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Microsoft AJAX DateTime.</h2>
<p>In some older MS implementations of AJAX, dates were encoded like </p><div class="fragment"><div class="line">&quot;/Date(725842800000+0100)/&quot;</div>
</div><!-- fragment --><p>where the first number is the number of seconds since UNIX epoch, and then, optionally, followed by an offset.</p>
<p>Taking the first example, modified the time to use the MS AJAX format, the timestamp only has 1s resolution and is a number.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;name&quot;: &quot;Toronto&quot;,</div>
<div class="line">  &quot;timestamp&quot;: &quot;/DATE(1577928874)/&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>When parsing the <code>timestamp</code> member we need to skip the first 6 characters, optionally verifying it says <code>"/DATE(</code>. Then parse the number and add it to a <code>std::chrono</code> timestamp with the time of Unix Epoc, Midight January 1, 1970.</p>
<p>Too see a working example using this code, refer to <a href="../tests/src/cookbook_dates4_test.cpp">cookbook_dates4_test.cpp</a></p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">using timepoint_t = std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::milliseconds&gt;;</div>
<div class="line">struct TimestampConverter {</div>
<div class="line"> timepoint_t operator( )( std::string_view sv ) const {</div>
<div class="line">    auto sv2 = daw::string_view( sv.data( ), sv.size( ) );</div>
<div class="line">    daw::string_view const prefix = &quot;/DATE(&quot;;</div>
<div class="line">    daw::string_view const suffix = &quot;)/&quot;;</div>
<div class="line">    daw_json_assert( sv2.starts_with( prefix ), &quot;Unexpected date format&quot; );</div>
<div class="line">    daw_json_assert( sv2.ends_with( suffix ), &quot;Unexpected date format&quot; );</div>
<div class="line">    sv2.remove_prefix( prefix.size( ) );</div>
<div class="line">    sv2.remove_suffix( suffix.size( ) );</div>
<div class="line"> </div>
<div class="line">    int64_t val =</div>
<div class="line">      daw::json::from_json&lt;int64_t, daw::json::NoCommentSkippingPolicyChecked,</div>
<div class="line">                           true&gt;( sv2 );</div>
<div class="line">    const auto epoch =</div>
<div class="line">      daw::json::datetime::civil_to_time_point( 1970, 1, 1, 0, 0, 0, 0 );</div>
<div class="line"> </div>
<div class="line">    return epoch + std::chrono::seconds( val );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Same class as above, but the JSON encoding differs</div>
<div class="line">struct MyClass4 {</div>
<div class="line">  std::string name;</div>
<div class="line">  timepoint_t timestamp;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">namespace daw::json {</div>
<div class="line">  template&lt;&gt;</div>
<div class="line">  struct json_data_contract&lt;MyClass4&gt; {</div>
<div class="line">    using type = json_member_list&lt;</div>
<div class="line">      json_string&lt;&quot;name&quot;&gt;,</div>
<div class="line">      json_custom&lt;&quot;timestamp&quot;, </div>
<div class="line">        timepoint_t, </div>
<div class="line">        TimestampConverter, </div>
<div class="line">        TimestampConverter</div>
<div class="line">      &gt;</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">    static inline auto to_json_data( MyClass4 const &amp; v ) {</div>
<div class="line">      return std::forward_as_tuple( v.name, v.timestamp );</div>
<div class="line">    }   </div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line">// ...</div>
<div class="line">timepoint_t my_timepoint = daw::json::from_json&lt;MyClass4&gt;( json_document );</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
